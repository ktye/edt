#include <stdlib.h>
#include <windows.h>

LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
HWND hedt;
int match(char *buf, int x, int s, int n) {
	int i; 
	for (i=0; i<n; i++) {
		if (buf[x+i] != buf[s+i]) {
			return 0;
		}
	}
	return 1;
}
int find(char *buf, int total, int s, int sn, int start) {
	int i; for (i=start; i<total; i++) {
		if ((buf[i] == buf[s]) && match(buf, i, s, sn)) {
			return i;
		}
	}
	return -1;
}
void search() {
	int i, n, next;
	LONG x, y, total;
	WPARAM wParam;
	LPARAM lParam;
	char *buf;
	SendMessage(hedt, EM_GETSEL, (WPARAM)&x, (LPARAM)&y);
	n = y-x;
	if (x > y) {
		n = x - y;
		x = y;
	}
	total = SendMessage(hedt, WM_GETTEXTLENGTH, 0, 0);
	total++;
	buf = malloc(total);
	if (!buf) return;
	total = SendMessage(hedt, WM_GETTEXT, (WPARAM)total, (LPARAM)buf);
	next = find(buf, total, x, n, x+1);
	if (next > 0) {
		SendMessage(hedt, EM_SETSEL, next, next+n);
	} else {
		next = find(buf, total, x, n, 0);
		SendMessage(hedt, EM_SETSEL, next, next+n);
	}
	free(buf);
}
int linestart(char *buf, int x) {
	int i, p = 0;
	for (i=0; i<x; i++) {
		if (buf[i] == '\n') {
			p = i;
		}
	}
	return p;
}
void exec() {}
void execute() {
	int i, x, y, total;
	char *buf;
	SendMessage(hedt, EM_GETSEL, (WPARAM)&x, (LPARAM)&y);
	if (x > y) {
		i = x;
		x = y;
		y = i;
	}
	total = SendMessage(hedt, WM_GETTEXTLENGTH, 0, 0);
	total++;
	buf = malloc(total);
	if (x == y) {
		exec(buf, linestart(buf, x), y);
	} else {
		exec(buf, x, y);
	}
	free(buf);
}
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR nCmdLine, int nCmdShow) {
	MSG msg;
	WNDCLASS wc;
	HWND hwnd;
	HFONT hf;
	HDC hdc;
	long lfHeight;
	
	hdc = GetDC(NULL);
	lfHeight = -MulDiv(16, GetDeviceCaps(hdc, LOGPIXELSY), 72);
	ReleaseDC(NULL, hdc);
	hf = CreateFont(lfHeight, 0, 0, 0, 500, 0, 0, 0, 0, 0, 0, 0, 0, "Iosevka Term SS04");
	
	ZeroMemory(&wc, sizeof wc);
	wc.hInstance     = hInstance;
	wc.lpszClassName = "e";
	wc.lpfnWndProc   = (WNDPROC)WndProc;
	wc.style         = CS_DBLCLKS|CS_VREDRAW|CS_HREDRAW;
	wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
	wc.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);

	if (FALSE == RegisterClass(&wc)) return 0;
	hwnd = CreateWindow("e", "e", WS_OVERLAPPEDWINDOW|WS_VISIBLE, CW_USEDEFAULT, CW_USEDEFAULT, 600, 400, 0, 0, hInstance, 0);
	hedt =            CreateWindow(TEXT("Edit"), "textarea", WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL | ES_MULTILINE | WS_VSCROLL, 0, 0, 600, 400, hwnd, NULL, NULL, NULL);
	
  	ShowWindow(hwnd, nCmdShow);
  	UpdateWindow(hwnd);
	SendMessage(hedt, WM_SETFONT, (WPARAM)hf, MAKELPARAM(1, 0));
	int i = 0;
  	while (GetMessage(&msg, NULL, 0, 0) > 0) {
		if (msg.message == WM_RBUTTONDOWN) {
			search();
			continue;
		} else if (msg.message == WM_CHAR) {
			if (msg.wParam == 13) {
				execute();
				continue;
			}
		}
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return msg.wParam;
}
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	switch (msg) {
	case WM_CREATE:
		break;
	case WM_SIZE:
		MoveWindow(hedt, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
		break;
	case WM_SIZING:
		SetWindowText(hedt,"sizing");
		break;
	case WM_DESTROY:
    		PostQuitMessage(WM_QUIT);
		break;
	default:
		return DefWindowProc(hwnd, msg, wParam, lParam);
	}
  	return FALSE;
}
